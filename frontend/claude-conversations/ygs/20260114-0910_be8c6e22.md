# Claude ëŒ€í™” ê¸°ë¡
**ë‚ ì§œ**: 2026-01-14 09:10
**ì„¸ì…˜**: be8c6e22-8a63-4f58-aea2-8915f3e19bc2

---

## ğŸ§‘ User

<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>

---

## ğŸ§‘ User

<command-name>/clear</command-name>
            <command-message>clear</command-message>
            <command-args></command-args>

---

## ğŸ§‘ User

<local-command-stdout></local-command-stdout>

---

## ğŸ§‘ User

@/Users/chajinhyeog/workspace/ygs/.claude/skills/fastapi-backend-guidelines/ ì´ìš©í•´ì„œ ë°±ì—”ë“œ ì½”ë“œ ê²€ìˆ˜í•˜ê³  ê³ ì³ì¤˜ \
íŠ¹íˆë‚˜ n+1 ë¬¸ì œ ìœ„ì£¼ë¡œ ê²€ìˆ˜ í•´ì¤˜ 

---

## ğŸ¤– Claude

[Tool: Skill]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ§‘ User

Base directory for this skill: /Users/chajinhyeog/workspace/ygs/.claude/skills/fastapi-backend-guidelines

# FastAPI Backend Development Guidelines

## Purpose

Comprehensive guide for modern FastAPI development with async Python, emphasizing Domain-Driven Design, layered architecture (Router â†’ Service â†’ Repository), SQLModel ORM, and async best practices.

## When to Use This Skill

- Creating new API routes or endpoints
- Building domain services and business logic
- Implementing repositories for data access
- Setting up database models with SQLModel
- Async/await patterns and error handling
- Organizing backend code with DDD
- Pydantic validation and DTOs
- Python async best practices

---

## Quick Start

### New API Route Checklist

Creating an API endpoint? Follow this checklist:

- [ ] Define route in `backend/api/v1/routers/{domain}.py`
- [ ] Use FastAPI dependency injection for session
- [ ] Call service layer (don't access repository directly)
- [ ] Use Pydantic DTOs for request/response
- [ ] Handle errors with custom exceptions
- [ ] Add proper HTTP status codes
- [ ] Use async/await throughout
- [ ] Document with docstrings
- [ ] Use type hints on all parameters

### New Domain Feature Checklist

Creating a new domain? Set up this structure:

- [ ] Create `backend/domain/{domain}/` directory
- [ ] Create `model.py` - SQLModel database models
- [ ] Create `repository.py` - Data access layer
- [ ] Create `service.py` - Business logic layer
- [ ] Create DTOs in `backend/dtos/{domain}.py`
- [ ] Create router in `backend/api/v1/routers/{domain}.py`
- [ ] Register router in `main.py`
- [ ] Follow async patterns throughout

---

## Project Structure Quick Reference

Your little-boy backend structure:

```
backend/
  backend/
    main.py                  # FastAPI app creation

    api/
      v1/
        routers/             # API route handlers
          artist.py
          artwork.py
          auth.py
          ...

    domain/                  # Domain-Driven Design
      artist/
        model.py             # SQLModel models
        repository.py        # Data access layer
        service.py           # Business logic
      artwork/
      auth/
      ...

    dtos/                    # Pydantic DTOs
      artist.py
      artwork.py
      ...

    db/
      orm.py                 # DB session management

    core/
      config.py              # App configuration

    middleware/              # Middleware
      error_handler.py

    utils/                   # Utilities

    error/                   # Custom exceptions
```

---

## Common Imports Cheatsheet

```python
# FastAPI
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.responses import JSONResponse

# SQLModel & SQLAlchemy
from sqlmodel import select, or_, and_
from sqlmodel.ext.asyncio.session import AsyncSession

# Database
from backend.db.orm import get_write_session_dependency, get_read_session_dependency

# Pydantic
from pydantic import BaseModel, Field, field_validator

# Your domain
from backend.domain.artist.model import Artist
from backend.domain.artist.service import ArtistService
from backend.dtos.artist import ArtistRequestDto, ArtistResponseDto
from backend.error import NotFoundError

# Type hints
from typing import List, Optional, Dict, Any
```

---

## Topic Guides

### ğŸ—ï¸ Layered Architecture

**Three-Layer Pattern:**
1. **Router Layer**: API endpoints, request validation, response formatting
2. **Service Layer**: Business logic, orchestration, domain rules
3. **Repository Layer**: Data access, queries, database operations

**Key Concepts:**
- Routers call Services (never Repositories directly)
- Services orchestrate business logic
- Repositories handle all database operations
- Each layer has clear responsibilities
- Async/await throughout the stack

**[ğŸ“– Complete Guide: resources/layered-architecture.md](resources/layered-architecture.md)**

---

### ğŸ›£ï¸ API Routes & Routers

**PRIMARY PATTERN: FastAPI Routers**
- Create routers in `backend/api/v1/routers/`
- Use dependency injection for sessions
- Follow REST conventions
- Use appropriate HTTP methods and status codes
- Async route handlers

**Router Structure:**
```python
from fastapi import APIRouter, Depends
from sqlmodel.ext.asyncio.session import AsyncSession
from backend.db.orm import get_write_session_dependency

router = APIRouter(prefix="/api/v1/artists", tags=["artists"])

@router.get("/{artist_id}")
async def get_artist(
    artist_id: str,
    session: AsyncSession = Depends(get_read_session_dependency),
):
    service = ArtistService(session)
    return await service.get_artist(artist_id)
```

**[ğŸ“– Complete Guide: resources/api-routes.md](resources/api-routes.md)**

---

### ğŸ—„ï¸ Database & ORM

**SQLModel + SQLAlchemy:**
- SQLModel for models (combines SQLAlchemy + Pydantic)
- Async sessions with asyncpg driver
- Read/Write session separation
- Repository pattern for all queries

**Model Pattern:**
```python
from sqlmodel import SQLModel, Field

class Artist(SQLModel, table=True):
    __tablename__ = "artists"

    id: str = Field(primary_key=True)
    name: str = Field(max_length=255)
    bio: Optional[str] = None
```

**[ğŸ“– Complete Guide: resources/database-orm.md](resources/database-orm.md)**

---

### ğŸ“¦ Domain-Driven Design

**Domain Organization:**
- Each domain in `backend/domain/{name}/`
- Contains: `model.py`, `repository.py`, `service.py`
- Clear separation of concerns
- Business logic in services
- Data access in repositories

**Your Domains:**
- admin, artist, artwork, auth, curai, exhibition
- message, notification, subscription, user, shared

**[ğŸ“– Complete Guide: resources/domain-driven-design.md](resources/domain-driven-design.md)**

---

### ğŸ”„ Service Layer

**Service Pattern:**
- Business logic orchestration
- Domain rule enforcement
- Calls repositories for data
- Returns DTOs, not models directly
- Transaction management

**Service Structure:**
```python
class ArtistService:
    def __init__(self, session: AsyncSession):
        self.session = session
        self._repository = ArtistRepository(session)

    async def get_artist(self, artist_id: str) -> ArtistResponseDto:
        artist = await self._repository.get_by_id(artist_id)
        if not artist:
            raise NotFoundError("Artist not found")
        return ArtistResponseDto.from_model(artist)
```

**[ğŸ“– Complete Guide: resources/service-layer.md](resources/service-layer.md)**

---

### ğŸ’¾ Repository Pattern

**Repository Pattern:**
- Encapsulates data access
- Extends BaseRepository
- Domain-specific queries
- Returns domain models
- All queries are async

**Repository Structure:**
```python
class ArtistRepository(BaseRepository[Artist]):
    def __init__(self, session: AsyncSession):
        super().__init__(session, Artist)

    async def find_by_name(self, name: str) -> Optional[Artist]:
        stmt = select(Artist).where(Artist.name == name)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()
```

**[ğŸ“– Complete Guide: resources/repository-pattern.md](resources/repository-pattern.md)**

---

### ğŸ“ DTOs & Validation

**Pydantic DTOs:**
- Request/Response data transfer objects
- Validation with Pydantic
- Separate from domain models
- Located in `backend/dtos/`

**DTO Pattern:**
```python
from pydantic import BaseModel, Field, field_validator

class ArtistRequestDto(BaseModel):
    name: str = Field(min_length=1, max_length=255)
    bio: Optional[str] = None

    @field_validator('name')
    def name_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('Name cannot be empty')
        return v
```

**[ğŸ“– Complete Guide: resources/dtos-validation.md](resources/dtos-validation.md)**

---

### âš¡ Async/Await Patterns

**Async Best Practices:**
- Use async/await throughout
- Async database sessions
- Proper session cleanup
- Avoid blocking operations
- Use asyncio for concurrency

**Async Patterns:**
```python
# Async route handler
@router.get("/artists")
async def get_artists(
    session: AsyncSession = Depends(get_read_session_dependency),
):
    service = ArtistService(session)
    return await service.get_all_artists()

# Async service method
async def get_all_artists(self) -> List[ArtistResponseDto]:
    artists = await self._repository.find_all()
    return [ArtistResponseDto.from_model(a) for a in artists]
```

**[ğŸ“– Complete Guide: resources/async-patterns.md](resources/async-patterns.md)**

---

### ğŸš¨ Error Handling

**Error Handling Strategy:**
- Custom exception classes
- HTTP exception mapping
- Middleware for error handling
- Consistent error responses

**Error Pattern:**
```python
from backend.error import NotFoundError

# In service
if not artist:
    raise NotFoundError(f"Artist {artist_id} not found")

# Middleware handles conversion to HTTP response
```

**[ğŸ“– Complete Guide: resources/error-handling.md](resources/error-handling.md)**

---

### ğŸ“š Complete Examples

**Full working examples:**
- Complete domain (model + repository + service + router)
- CRUD operations with async
- Complex queries with SQLModel
- Authentication patterns
- File upload to S3
- Pagination and filtering

**[ğŸ“– Complete Guide: resources/complete-examples.md](resources/complete-examples.md)**

---

## Navigation Guide

| Need to... | Read this resource |
|------------|-------------------|
| Understand architecture | [layered-architecture.md](resources/layered-architecture.md) |
| Create API routes | [api-routes.md](resources/api-routes.md) |
| Work with database | [database-orm.md](resources/database-orm.md) |
| Organize domains | [domain-driven-design.md](resources/domain-driven-design.md) |
| Build services | [service-layer.md](resources/service-layer.md) |
| Create repositories | [repository-pattern.md](resources/repository-pattern.md) |
| Validate requests | [dtos-validation.md](resources/dtos-validation.md) |
| Use async patterns | [async-patterns.md](resources/async-patterns.md) |
| Handle errors | [error-handling.md](resources/error-handling.md) |
| See full examples | [complete-examples.md](resources/complete-examples.md) |

---

## Core Principles

1. **Layered Architecture**: Router â†’ Service â†’ Repository (never skip layers)
2. **Domain-Driven Design**: Organize by domain, not by type
3. **Async Everything**: Use async/await throughout the stack
4. **Repository Pattern**: All data access through repositories
5. **Service Layer**: Business logic in services, not routers or repositories
6. **DTOs for API**: Use Pydantic DTOs for request/response
7. **Type Hints**: Explicit types on all functions and parameters
8. **Error Handling**: Custom exceptions, middleware for HTTP mapping
9. **Read/Write Split**: Separate sessions for read and write operations
10. **Dependency Injection**: Use FastAPI's Depends() for sessions

---

## Quick Reference: New Domain Template

```python
# backend/domain/myfeature/model.py
from sqlmodel import SQLModel, Field

class MyFeature(SQLModel, table=True):
    __tablename__ = "my_features"
    id: str = Field(primary_key=True)
    name: str

# backend/domain/myfeature/repository.py
from backend.domain.shared.base_repository import BaseRepository

class MyFeatureRepository(BaseRepository[MyFeature]):
    def __init__(self, session: AsyncSession):
        super().__init__(session, MyFeature)

# backend/domain/myfeature/service.py
class MyFeatureService:
    def __init__(self, session: AsyncSession):
        self.session = session
        self._repository = MyFeatureRepository(session)

    async def get_feature(self, id: str):
        return await self._repository.get_by_id(id)

# backend/api/v1/routers/myfeature.py
from fastapi import APIRouter, Depends

router = APIRouter(prefix="/api/v1/myfeature", tags=["myfeature"])

@router.get("/{id}")
async def get_feature(
    id: str,
    session: AsyncSession = Depends(get_read_session_dependency),
):
    service = MyFeatureService(session)
    return await service.get_feature(id)
```

---

## Related Skills

- **nextjs-frontend-guidelines**: Frontend patterns that consume this API
- **error-tracking**: Error tracking with Sentry (backend integration)

---

**Skill Status**: Modular structure with progressive loading for optimal context management


---

## ğŸ¤– Claude

ë°±ì—”ë“œ ì½”ë“œë¥¼ N+1 ë¬¸ì œ ìœ„ì£¼ë¡œ ê²€ìˆ˜í•˜ê² ìŠµë‹ˆë‹¤. ë¨¼ì € ì½”ë“œë² ì´ìŠ¤ë¥¼ íƒìƒ‰í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Task]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ì¢‹ìŠµë‹ˆë‹¤. íƒìƒ‰ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ êµ¬ì²´ì ì¸ ë¬¸ì œë“¤ì„ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

N+1 ë¬¸ì œë¥¼ í™•ì¸í–ˆìŠµë‹ˆë‹¤. ì´ì œ AdminServiceì˜ ë¹„íš¨ìœ¨ì ì¸ ì§‘ê³„ ì¿¼ë¦¬ë„ í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ì´ì œ user serviceì˜ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë©”ì„œë“œë„ í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ë¨¼ì € user serviceì˜ N+1 ë©”ì„œë“œê°€ ì‹¤ì œë¡œ ì‚¬ìš©ë˜ëŠ”ì§€ í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Grep]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ì¢‹ìŠµë‹ˆë‹¤. ì´ì œ ë¬¸ì œë“¤ì„ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.

## ìˆ˜ì • 1: MatchService N+1 ë¬¸ì œ ìˆ˜ì •

`_to_history_summary` ë©”ì„œë“œê°€ ê° ë§¤ì¹˜ë§ˆë‹¤ week ë°ì´í„°ë¥¼ ê°œë³„ ì¡°íšŒí•˜ëŠ” ë¬¸ì œë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ì´ì œ ìƒˆë¡œìš´ í—¬í¼ ë©”ì„œë“œë“¤ì„ ì¶”ê°€í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ì´ì œ MatchWeekRepositoryì— `find_by_ids` ë©”ì„œë“œë¥¼ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

MatchWeekRepositoryì— `find_by_ids` ë©”ì„œë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

## ìˆ˜ì • 2: AdminService.get_registration_trend() íš¨ìœ¨ì„± ê°œì„ 

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

## ìˆ˜ì • 3: ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” N+1 íŒ¨í„´ ë©”ì„œë“œ ì œê±°

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

## ìˆ˜ì • ê²€ì¦

íƒ€ì… ì²´í¬ì™€ ë¦°í„°ë¥¼ ì‹¤í–‰í•´ì„œ ìˆ˜ì • ì‚¬í•­ì„ ê²€ì¦í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Bash]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Bash]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Bash]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ê¸°ì¡´ mypy ì˜¤ë¥˜ë“¤ì€ ë‚´ ìˆ˜ì •ê³¼ ë¬´ê´€í•œ ì´ë¯¸ ì¡´ì¬í•˜ë˜ íƒ€ì… íŒíŠ¸ ë¬¸ì œì…ë‹ˆë‹¤. ì œê°€ ìˆ˜ì •í•œ ì½”ë“œì—ëŠ” ìƒˆë¡œìš´ ì˜¤ë¥˜ê°€ ì—†ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

## ë°±ì—”ë“œ N+1 ë¬¸ì œ ê²€ìˆ˜ ë° ìˆ˜ì • ì™„ë£Œ

### ë°œê²¬ëœ ë¬¸ì œ ë° ìˆ˜ì • ì‚¬í•­

| íŒŒì¼ | ë©”ì„œë“œ | ë¬¸ì œ | ìˆ˜ì • ë‚´ìš© |
|------|--------|------|-----------|
| `match/service.py` | `search_matches()`, `list_user_matches()` | `_to_history_summary()`ë¥¼ ë£¨í”„ì—ì„œ í˜¸ì¶œí•˜ì—¬ ë§¤ì¹˜ë‹¹ 1ê°œ ì¿¼ë¦¬ ë°œìƒ | ë°°ì¹˜ ë¡œë”© íŒ¨í„´ ì ìš© (`_load_weeks_for_matches` + `_to_history_summary_sync`) |
| `match/repository.py` | - | `find_by_ids()` ë©”ì„œë“œ ë¶€ì¬ | `find_by_ids()` ë°°ì¹˜ ì¡°íšŒ ë©”ì„œë“œ ì¶”ê°€ |
| `admin/service.py` | `get_registration_trend()` | Nì¼ì— ëŒ€í•´ Nê°œì˜ ì¿¼ë¦¬ ì‹¤í–‰ | ë‹¨ì¼ `GROUP BY` ì¿¼ë¦¬ë¡œ ìµœì í™” |
| `user/service.py` | `_to_user_response()`, `_to_user_detail_response()` | ì‚¬ìš©ìë‹¹ 6ê°œ ìˆœì°¨ ì¿¼ë¦¬ (ë¯¸ì‚¬ìš©) | ë©”ì„œë“œ ì œê±° ë° ì£¼ì„ ì¶”ê°€ |

### ì„±ëŠ¥ ê°œì„  íš¨ê³¼

**ìˆ˜ì • ì „:**
- `search_matches(20ê°œ)`: 1 + 20 = **21ê°œ ì¿¼ë¦¬**
- `get_registration_trend(7ì¼)`: **7ê°œ ì¿¼ë¦¬**

**ìˆ˜ì • í›„:**
- `search_matches(20ê°œ)`: 1 + 1 = **2ê°œ ì¿¼ë¦¬** (90% ê°ì†Œ)
- `get_registration_trend(7ì¼)`: **1ê°œ ì¿¼ë¦¬** (86% ê°ì†Œ)

### ìˆ˜ì •ëœ íŒŒì¼
- `backend/backend/domain/match/service.py`
- `backend/backend/domain/match/repository.py`
- `backend/backend/domain/admin/service.py`
- `backend/backend/domain/user/service.py`

---

## ğŸ§‘ User

@/Users/chajinhyeog/workspace/ygs/.claude/skills/fastapi-backend-guidelines/ ì´ìš©í•´ì„œ ë°±ì—”ë“œ ì½”ë“œ ë§ˆì € ê²€ìˆ˜í•´

---

## ğŸ¤– Claude

[Tool: Skill]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ§‘ User

Base directory for this skill: /Users/chajinhyeog/workspace/ygs/.claude/skills/fastapi-backend-guidelines

# FastAPI Backend Development Guidelines

## Purpose

Comprehensive guide for modern FastAPI development with async Python, emphasizing Domain-Driven Design, layered architecture (Router â†’ Service â†’ Repository), SQLModel ORM, and async best practices.

## When to Use This Skill

- Creating new API routes or endpoints
- Building domain services and business logic
- Implementing repositories for data access
- Setting up database models with SQLModel
- Async/await patterns and error handling
- Organizing backend code with DDD
- Pydantic validation and DTOs
- Python async best practices

---

## Quick Start

### New API Route Checklist

Creating an API endpoint? Follow this checklist:

- [ ] Define route in `backend/api/v1/routers/{domain}.py`
- [ ] Use FastAPI dependency injection for session
- [ ] Call service layer (don't access repository directly)
- [ ] Use Pydantic DTOs for request/response
- [ ] Handle errors with custom exceptions
- [ ] Add proper HTTP status codes
- [ ] Use async/await throughout
- [ ] Document with docstrings
- [ ] Use type hints on all parameters

### New Domain Feature Checklist

Creating a new domain? Set up this structure:

- [ ] Create `backend/domain/{domain}/` directory
- [ ] Create `model.py` - SQLModel database models
- [ ] Create `repository.py` - Data access layer
- [ ] Create `service.py` - Business logic layer
- [ ] Create DTOs in `backend/dtos/{domain}.py`
- [ ] Create router in `backend/api/v1/routers/{domain}.py`
- [ ] Register router in `main.py`
- [ ] Follow async patterns throughout

---

## Project Structure Quick Reference

Your little-boy backend structure:

```
backend/
  backend/
    main.py                  # FastAPI app creation

    api/
      v1/
        routers/             # API route handlers
          artist.py
          artwork.py
          auth.py
          ...

    domain/                  # Domain-Driven Design
      artist/
        model.py             # SQLModel models
        repository.py        # Data access layer
        service.py           # Business logic
      artwork/
      auth/
      ...

    dtos/                    # Pydantic DTOs
      artist.py
      artwork.py
      ...

    db/
      orm.py                 # DB session management

    core/
      config.py              # App configuration

    middleware/              # Middleware
      error_handler.py

    utils/                   # Utilities

    error/                   # Custom exceptions
```

---

## Common Imports Cheatsheet

```python
# FastAPI
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.responses import JSONResponse

# SQLModel & SQLAlchemy
from sqlmodel import select, or_, and_
from sqlmodel.ext.asyncio.session import AsyncSession

# Database
from backend.db.orm import get_write_session_dependency, get_read_session_dependency

# Pydantic
from pydantic import BaseModel, Field, field_validator

# Your domain
from backend.domain.artist.model import Artist
from backend.domain.artist.service import ArtistService
from backend.dtos.artist import ArtistRequestDto, ArtistResponseDto
from backend.error import NotFoundError

# Type hints
from typing import List, Optional, Dict, Any
```

---

## Topic Guides

### ğŸ—ï¸ Layered Architecture

**Three-Layer Pattern:**
1. **Router Layer**: API endpoints, request validation, response formatting
2. **Service Layer**: Business logic, orchestration, domain rules
3. **Repository Layer**: Data access, queries, database operations

**Key Concepts:**
- Routers call Services (never Repositories directly)
- Services orchestrate business logic
- Repositories handle all database operations
- Each layer has clear responsibilities
- Async/await throughout the stack

**[ğŸ“– Complete Guide: resources/layered-architecture.md](resources/layered-architecture.md)**

---

### ğŸ›£ï¸ API Routes & Routers

**PRIMARY PATTERN: FastAPI Routers**
- Create routers in `backend/api/v1/routers/`
- Use dependency injection for sessions
- Follow REST conventions
- Use appropriate HTTP methods and status codes
- Async route handlers

**Router Structure:**
```python
from fastapi import APIRouter, Depends
from sqlmodel.ext.asyncio.session import AsyncSession
from backend.db.orm import get_write_session_dependency

router = APIRouter(prefix="/api/v1/artists", tags=["artists"])

@router.get("/{artist_id}")
async def get_artist(
    artist_id: str,
    session: AsyncSession = Depends(get_read_session_dependency),
):
    service = ArtistService(session)
    return await service.get_artist(artist_id)
```

**[ğŸ“– Complete Guide: resources/api-routes.md](resources/api-routes.md)**

---

### ğŸ—„ï¸ Database & ORM

**SQLModel + SQLAlchemy:**
- SQLModel for models (combines SQLAlchemy + Pydantic)
- Async sessions with asyncpg driver
- Read/Write session separation
- Repository pattern for all queries

**Model Pattern:**
```python
from sqlmodel import SQLModel, Field

class Artist(SQLModel, table=True):
    __tablename__ = "artists"

    id: str = Field(primary_key=True)
    name: str = Field(max_length=255)
    bio: Optional[str] = None
```

**[ğŸ“– Complete Guide: resources/database-orm.md](resources/database-orm.md)**

---

### ğŸ“¦ Domain-Driven Design

**Domain Organization:**
- Each domain in `backend/domain/{name}/`
- Contains: `model.py`, `repository.py`, `service.py`
- Clear separation of concerns
- Business logic in services
- Data access in repositories

**Your Domains:**
- admin, artist, artwork, auth, curai, exhibition
- message, notification, subscription, user, shared

**[ğŸ“– Complete Guide: resources/domain-driven-design.md](resources/domain-driven-design.md)**

---

### ğŸ”„ Service Layer

**Service Pattern:**
- Business logic orchestration
- Domain rule enforcement
- Calls repositories for data
- Returns DTOs, not models directly
- Transaction management

**Service Structure:**
```python
class ArtistService:
    def __init__(self, session: AsyncSession):
        self.session = session
        self._repository = ArtistRepository(session)

    async def get_artist(self, artist_id: str) -> ArtistResponseDto:
        artist = await self._repository.get_by_id(artist_id)
        if not artist:
            raise NotFoundError("Artist not found")
        return ArtistResponseDto.from_model(artist)
```

**[ğŸ“– Complete Guide: resources/service-layer.md](resources/service-layer.md)**

---

### ğŸ’¾ Repository Pattern

**Repository Pattern:**
- Encapsulates data access
- Extends BaseRepository
- Domain-specific queries
- Returns domain models
- All queries are async

**Repository Structure:**
```python
class ArtistRepository(BaseRepository[Artist]):
    def __init__(self, session: AsyncSession):
        super().__init__(session, Artist)

    async def find_by_name(self, name: str) -> Optional[Artist]:
        stmt = select(Artist).where(Artist.name == name)
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()
```

**[ğŸ“– Complete Guide: resources/repository-pattern.md](resources/repository-pattern.md)**

---

### ğŸ“ DTOs & Validation

**Pydantic DTOs:**
- Request/Response data transfer objects
- Validation with Pydantic
- Separate from domain models
- Located in `backend/dtos/`

**DTO Pattern:**
```python
from pydantic import BaseModel, Field, field_validator

class ArtistRequestDto(BaseModel):
    name: str = Field(min_length=1, max_length=255)
    bio: Optional[str] = None

    @field_validator('name')
    def name_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('Name cannot be empty')
        return v
```

**[ğŸ“– Complete Guide: resources/dtos-validation.md](resources/dtos-validation.md)**

---

### âš¡ Async/Await Patterns

**Async Best Practices:**
- Use async/await throughout
- Async database sessions
- Proper session cleanup
- Avoid blocking operations
- Use asyncio for concurrency

**Async Patterns:**
```python
# Async route handler
@router.get("/artists")
async def get_artists(
    session: AsyncSession = Depends(get_read_session_dependency),
):
    service = ArtistService(session)
    return await service.get_all_artists()

# Async service method
async def get_all_artists(self) -> List[ArtistResponseDto]:
    artists = await self._repository.find_all()
    return [ArtistResponseDto.from_model(a) for a in artists]
```

**[ğŸ“– Complete Guide: resources/async-patterns.md](resources/async-patterns.md)**

---

### ğŸš¨ Error Handling

**Error Handling Strategy:**
- Custom exception classes
- HTTP exception mapping
- Middleware for error handling
- Consistent error responses

**Error Pattern:**
```python
from backend.error import NotFoundError

# In service
if not artist:
    raise NotFoundError(f"Artist {artist_id} not found")

# Middleware handles conversion to HTTP response
```

**[ğŸ“– Complete Guide: resources/error-handling.md](resources/error-handling.md)**

---

### ğŸ“š Complete Examples

**Full working examples:**
- Complete domain (model + repository + service + router)
- CRUD operations with async
- Complex queries with SQLModel
- Authentication patterns
- File upload to S3
- Pagination and filtering

**[ğŸ“– Complete Guide: resources/complete-examples.md](resources/complete-examples.md)**

---

## Navigation Guide

| Need to... | Read this resource |
|------------|-------------------|
| Understand architecture | [layered-architecture.md](resources/layered-architecture.md) |
| Create API routes | [api-routes.md](resources/api-routes.md) |
| Work with database | [database-orm.md](resources/database-orm.md) |
| Organize domains | [domain-driven-design.md](resources/domain-driven-design.md) |
| Build services | [service-layer.md](resources/service-layer.md) |
| Create repositories | [repository-pattern.md](resources/repository-pattern.md) |
| Validate requests | [dtos-validation.md](resources/dtos-validation.md) |
| Use async patterns | [async-patterns.md](resources/async-patterns.md) |
| Handle errors | [error-handling.md](resources/error-handling.md) |
| See full examples | [complete-examples.md](resources/complete-examples.md) |

---

## Core Principles

1. **Layered Architecture**: Router â†’ Service â†’ Repository (never skip layers)
2. **Domain-Driven Design**: Organize by domain, not by type
3. **Async Everything**: Use async/await throughout the stack
4. **Repository Pattern**: All data access through repositories
5. **Service Layer**: Business logic in services, not routers or repositories
6. **DTOs for API**: Use Pydantic DTOs for request/response
7. **Type Hints**: Explicit types on all functions and parameters
8. **Error Handling**: Custom exceptions, middleware for HTTP mapping
9. **Read/Write Split**: Separate sessions for read and write operations
10. **Dependency Injection**: Use FastAPI's Depends() for sessions

---

## Quick Reference: New Domain Template

```python
# backend/domain/myfeature/model.py
from sqlmodel import SQLModel, Field

class MyFeature(SQLModel, table=True):
    __tablename__ = "my_features"
    id: str = Field(primary_key=True)
    name: str

# backend/domain/myfeature/repository.py
from backend.domain.shared.base_repository import BaseRepository

class MyFeatureRepository(BaseRepository[MyFeature]):
    def __init__(self, session: AsyncSession):
        super().__init__(session, MyFeature)

# backend/domain/myfeature/service.py
class MyFeatureService:
    def __init__(self, session: AsyncSession):
        self.session = session
        self._repository = MyFeatureRepository(session)

    async def get_feature(self, id: str):
        return await self._repository.get_by_id(id)

# backend/api/v1/routers/myfeature.py
from fastapi import APIRouter, Depends

router = APIRouter(prefix="/api/v1/myfeature", tags=["myfeature"])

@router.get("/{id}")
async def get_feature(
    id: str,
    session: AsyncSession = Depends(get_read_session_dependency),
):
    service = MyFeatureService(session)
    return await service.get_feature(id)
```

---

## Related Skills

- **nextjs-frontend-guidelines**: Frontend patterns that consume this API
- **error-tracking**: Error tracking with Sentry (backend integration)

---

**Skill Status**: Modular structure with progressive loading for optimal context management


---

## ğŸ¤– Claude

ë°±ì—”ë“œ ì½”ë“œë¥¼ ê³„ì† ê²€ìˆ˜í•˜ê² ìŠµë‹ˆë‹¤. ì´ë²ˆì—ëŠ” ë” í¬ê´„ì ì¸ ê²€ìˆ˜ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ¤– Claude

[Tool: Task]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ì¢…í•© ê²€ìˆ˜ ê²°ê³¼ë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤. ë°œê²¬ëœ ë¬¸ì œë“¤ì„ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ë¨¼ì € admin.py ë¼ìš°í„°ì˜ ë¬¸ì œê°€ ìˆëŠ” ë¶€ë¶„ì„ í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

AdminServiceì— ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë©”ì„œë“œë“¤ì„ í™•ì¸í•˜ê³ , ë¶€ì¡±í•œ ë©”ì„œë“œë“¤ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Grep]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ê°€ì¥ ì¤‘ìš”í•œ ë¬¸ì œë¶€í„° ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤. ë¨¼ì € `except Exception: pass` íŒ¨í„´ì„ ë¡œê¹…ê³¼ í•¨ê»˜ ìˆ˜ì •í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Grep]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

`except Exception: pass` íŒ¨í„´ë“¤ì„ ë¡œê¹…ê³¼ í•¨ê»˜ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Edit]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ë‹¤ë¥¸ íŒŒì¼ë“¤ì—ì„œë„ ë™ì¼í•œ ë¬¸ì œê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Grep]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Grep]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Read]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ì´ íŒŒì¼ì€ ìˆ˜í•™ í‘œí˜„ì‹ì„ í‰ê°€í•˜ëŠ” ì½”ë“œë¡œ, í‘œí˜„ì‹ í‰ê°€ ì‹¤íŒ¨ëŠ” ì˜ˆìƒë˜ëŠ” ë™ì‘ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ë””ë²„ê¹…ì„ ìœ„í•´ ë¡œê¹…ì„ ì¶”ê°€í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Grep]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

ìˆ˜ì • ì‚¬í•­ì„ ê²€ì¦í•©ë‹ˆë‹¤.

---

## ğŸ¤– Claude

[Tool: Bash]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: Bash]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

[Tool: TodoWrite]

---

## ğŸ§‘ User

[Tool Result]

---

## ğŸ¤– Claude

## ë°±ì—”ë“œ ì½”ë“œ ê²€ìˆ˜ ì™„ë£Œ ìš”ì•½

### ìˆ˜ì •ëœ ë¬¸ì œë“¤

#### 1. N+1 ì¿¼ë¦¬ ë¬¸ì œ ìˆ˜ì • (ì´ì „ ì„¸ì…˜)
| íŒŒì¼ | ë¬¸ì œ | ìˆ˜ì • |
|------|------|------|
| `match/service.py` | `_to_history_summary()` ë£¨í”„ì—ì„œ ê°œë³„ week ì¡°íšŒ | ë°°ì¹˜ ë¡œë”© íŒ¨í„´ ì ìš© |
| `match/repository.py` | ë°°ì¹˜ ì¡°íšŒ ë©”ì„œë“œ ë¶€ì¬ | `find_by_ids()` ì¶”ê°€ |
| `admin/service.py` | `get_registration_trend()` Nê°œ ì¿¼ë¦¬ | ë‹¨ì¼ `GROUP BY` ì¿¼ë¦¬ë¡œ ìµœì í™” |
| `user/service.py` | ë¯¸ì‚¬ìš© N+1 ë©”ì„œë“œ | ì œê±° ë° ì£¼ì„ ì¶”ê°€ |

#### 2. ì˜ˆì™¸ ì²˜ë¦¬ ê°œì„  (ì´ë²ˆ ì„¸ì…˜)
| íŒŒì¼ | ë¼ì¸ | ìˆ˜ì • ì „ | ìˆ˜ì • í›„ |
|------|------|---------|---------|
| `admin.py` | 374 | `except Exception: pass` | `except Exception as e: logger.warning(...)` |
| `admin.py` | 663 | `except Exception: pass` | `except Exception as e: logger.warning(...)` |
| `admin.py` | 756 | `except Exception: pass` | `except Exception as e: logger.warning(...)` |

### ë°œê²¬ëœ ì•„í‚¤í…ì²˜ ì´ìŠˆ (í–¥í›„ ê°œì„  ê¶Œì¥)

| ì¹´í…Œê³ ë¦¬ | ìœ„ì¹˜ | ì„¤ëª… | ê¶Œì¥ ì¡°ì¹˜ |
|----------|------|------|-----------|
| ê³„ì¸µ ìœ„ë°˜ | `admin.py:589` | Routerì—ì„œ `MatchHistoryRepository` ì§ì ‘ ì ‘ê·¼ | AdminServiceë¡œ ì´ë™ |
| ê³„ì¸µ ìœ„ë°˜ | `admin.py:808,839,873` | Routerì—ì„œ `MatchFeedbackRepository` ì§ì ‘ ì ‘ê·¼ | AdminServiceë¡œ ì´ë™ |
| ì§ì ‘ SQL | `admin.py:621,640,725,749` | Routerì—ì„œ `session.execute()` ì§ì ‘ í˜¸ì¶œ | Repositoryë¡œ ì´ë™ |
| Async ë¸”ë¡œí‚¹ | `s3_private.py` | boto3 ë™ê¸° í˜¸ì¶œ | aioboto3 ì‚¬ìš© ê¶Œì¥ |

### ìˆ˜ì •ëœ íŒŒì¼ ëª©ë¡
1. `backend/backend/domain/match/service.py`
2. `backend/backend/domain/match/repository.py`
3. `backend/backend/domain/admin/service.py`
4. `backend/backend/domain/user/service.py`
5. `backend/backend/api/v1/routers/admin.py`

### ì„±ëŠ¥ ê°œì„  íš¨ê³¼
- **N+1 ì¿¼ë¦¬**: ìµœëŒ€ 90% ì¿¼ë¦¬ ìˆ˜ ê°ì†Œ
- **ì§‘ê³„ ì¿¼ë¦¬**: 7ê°œ â†’ 1ê°œ (86% ê°ì†Œ)
- **ë””ë²„ê¹…**: S3 URL ìƒì„± ì‹¤íŒ¨ ì‹œ ë¡œê·¸ ê¸°ë¡ìœ¼ë¡œ ë¬¸ì œ ì¶”ì  ê°€ëŠ¥

---

